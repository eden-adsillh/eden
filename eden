#!/usr/bin/env python3

# Copyright (c) 2017-2018 Samuel Thibault <samuel.thibault@ens-lyon.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY Samuel Thibault ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import sys
import pygame
import argparse
import logging
import socket
import select
import threading

is_server   = False
is_snake    = False
woman_so    = None
man_so      = None
snake_so    = None

map = [ [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' ],
        [ ' ', 'X', 'X', 'X', 'X', 'X', 'X', ' ', 'X', ' ' ],
        [ ' ', 'X', ' ', ' ', ' ', 'S', ' ', ' ', 'X', ' ' ],
        [ ' ', 'X', ' ', 'X', ' ', 'X', 'X', ' ', 'X', '2' ],
        [ '1', 'X', ' ', 'X', 'A', 'X', 'X', ' ', 'X', ' ' ],
        [ ' ', 'X', ' ', 'X', ' ', ' ', ' ', ' ', 'X', ' ' ],
        [ ' ', 'X', ' ', 'X', 'X', 'X', 'X', 'X', 'X', ' ' ],
        [ ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' ] ]

width = len(map[0])
height = len(map)

# This is the sprites size
unit = 64
grass = (0x00, 0x90, 0x00)

# Parse arguments
def parse_args():
    parser = argparse.ArgumentParser(description="A little game about adam and Eve")
    parser.add_argument('-s','--server',
            help="Connect to server",
            dest='server')

    # Little hack for localhost tests
    parser.add_argument('-p', '--port',
            type=int,
            help='Port to bind the local socket')

    parser.add_argument('-d','--debug',
            help="Priont output messages",
            action='store_true',
            dest='debug')

    return parser.parse_args()
args = parse_args()

# Initialize socket
so = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
so_list = []
port = 7776
if args.server:
    woman_so = socket.create_connection((args.server, port))
    so_list.append(woman_so)
else:
    is_server = True

binding_port = port
if args.port:
    binding_port = args.port
so.bind(('', binding_port))
so.listen(1)
so_list.append(so)

# Waiting for opponent to connect if this is the server. Bypass if not
if is_server:
    print('Waiting for opponent to connect...')
    man_so, man_addr = so.accept()
    so_list.append(man_so)

# Pygame initialization
pygame.init()
screen = pygame.display.set_mode( (unit * width, unit * height) )
alpha = 128

# Load resources
woman = pygame.image.load("image/woman.png")
woman_ghost = woman.copy()
woman_ghost.fill((255, 255, 255, alpha), None, pygame.BLEND_RGBA_MULT)
woman_coords = [ 0, 0 ]
man = pygame.image.load("image/man.png")
man_ghost = man.copy()
man_ghost.fill((255, 255, 255, alpha), None, pygame.BLEND_RGBA_MULT)
man_coords = [ 0, 0 ]

snake = pygame.image.load("image/snake.png")
snake_ghost = snake.copy()
snake_ghost.fill((255, 255, 255, alpha), None, pygame.BLEND_RGBA_MULT)
snake_coords = [ 0, 0 ]

stone = pygame.image.load("image/stone.png")
stone_coords = [ 0, 0 ]

apple = pygame.image.load("image/apple.png")
apple_coords = [ 0, 0 ]

woman_move = [ 0, 0 ]
man_move = [ 0, 0 ]
snake_move = [ 0, 0 ]

# Initialize positions
def init():
    def find(coords, c):
        for y in range(len(map)):
            for x in range(len(map[y])):
                if map[y][x] == c:
                    coords[0] = x
                    coords[1] = y
                    return
        raise Exception('oops')

    find(woman_coords, '1')
    find(man_coords, '2')
    find(snake_coords, 'S')
    find(apple_coords, 'A')

def send_all(message):
    for socket in so_list:
        if socket != so:
            socket.send(message)

# Listening thread function
def socket_thread():
    global woman_move
    global man_move
    global snake_move
    global is_snake
    global snake_so
    global woman_so
    global man_so
    while True:
        rea, wri, exc = select.select(so_list, [], [])
        for item in rea:

            # Someone tries to connect ?
            # A new connection request in this function must be the snake as the
            # opponent has alredy connected from outside this function
            if item is so:
                # Bypass if there is already 3 players
                if len(so_list) < 3:
                    if is_server:
                        print('The snake has joined the game')
                        snake_so, snake_addr = item.accept()
                        so_list.append(snake_so)
                        # We send the socket informations of the snake to the opponent
                        # so he can connect to it and there is no centralised server
                        man_so.send(b'SNAKE ' + snake_addr[0].encode("UTF-8") + b':7779')

                    else:
                        is_snake = True
                        man_so, man_addr = item.accept()
                        so_list.append(man_so)

            # Else, it is not a connction request but a message
            elif item is woman_so:
                message = item.recv(1024)
                logging.info('Distant message recieved')
                if message == b'':
                    print("Woman\'s player left the game")
                    so_list.remove(item)
                elif message == b'UP':
                    woman_move =    [ 0, -1 ]
                elif message == b'DOWN':
                    woman_move =    [ 0, 1 ]
                elif message == b'LEFT':
                    woman_move =    [ -1, 0 ]
                elif message == b'RIGHT':
                    woman_move =    [ 1, 0 ]
                # Snake info received from server
                elif message[:5] == b'SNAKE':
                    snake_addr = message[6:].decode("UTF-8").split(":")
                    snake_so = socket.create_connection((snake_addr[0], int(snake_addr[1])))
                    so_list.append(snake_so)
            elif item is snake_so:
                message = item.recv(1024)
                logging.info('Distant message recieved')
                if message == b'':
                    print("Snake\'s player left the game")
                    so_list.remove(item)
                elif message == b'UP':
                    snake_move =    [ 0, -1 ]
                elif message == b'DOWN':
                    snake_move =    [ 0, 1 ]
                elif message == b'LEFT':
                    snake_move =    [ -1, 0 ]
                elif message == b'RIGHT':
                    snake_move =    [ 1, 0 ]
            elif item is man_so:
                message = item.recv(1024)
                logging.info('Distant message recieved')
                if message == b'':
                    print("Man\'s player left the game")
                    so_list.remove(item)
                elif message == b'UP':
                        man_move =    [ 0, -1 ]
                elif message == b'DOWN':
                        man_move =    [ 0, 1 ]
                elif message == b'LEFT':
                        man_move =    [ -1, 0 ]
                elif message == b'RIGHT':
                        man_move =    [ 1, 0 ]


# Launching the listening thread
threading.Thread(None, socket_thread).start()


init()

log_f='%(levelname)s:%(message)s'

if not args.debug:
    logging.basicConfig(format=log_f, level=logging.ERROR)
else:
    logging.basicConfig(format=log_f, level=logging.DEBUG)
    logging.debug("Debug mode activated")

while True:
    e = pygame.event.wait()

    # Check for exit
    if e.type == pygame.QUIT:
        sys.exit()

    elif e.type == pygame.KEYDOWN:
        if is_server:
            # Check for woman movements
            if woman_move == [ 0, 0 ]:

                if e.key == pygame.K_UP:
                    woman_move = [ 0, -1 ]
                    send_all(b'UP')
                    pass
                elif e.key == pygame.K_DOWN:
                    woman_move = [ 0, 1 ]
                    send_all(b'DOWN')
                    pass
                elif e.key == pygame.K_LEFT:
                    woman_move = [ -1, 0 ]
                    send_all(b'LEFT')
                    pass
                elif e.key == pygame.K_RIGHT:
                    woman_move = [ 1, 0 ]
                    send_all(b'RIGHT')
                    pass

        elif is_snake:
            # Check for snake movements
            if snake_move == [ 0, 0 ]:

                if e.key == pygame.K_UP:
                    snake_move = [ 0, -1 ]
                    send_all(b'UP')
                    pass
                elif e.key == pygame.K_DOWN:
                    snake_move = [ 0, 1 ]
                    send_all(b'DOWN')
                    pass
                elif e.key == pygame.K_LEFT:
                    snake_move = [ -1, 0 ]
                    send_all(b'LEFT')
                    pass
                elif e.key == pygame.K_RIGHT:
                    snake_move = [ 1, 0 ]
                    send_all(b'RIGHT')
                    pass

        else:
            # Check for man movements
            if man_move == [ 0, 0 ]:

                if e.key == pygame.K_UP:
                    man_move = [ 0, -1 ]
                    send_all(b'UP')
                    pass
                elif e.key == pygame.K_DOWN:
                    man_move = [ 0, 1 ]
                    send_all(b'DOWN')
                    pass
                elif e.key == pygame.K_LEFT:
                    man_move = [ -1, 0 ]
                    send_all(b'LEFT')
                    pass
                elif e.key == pygame.K_RIGHT:
                    man_move = [ 1, 0 ]
                    send_all(b'RIGHT')
                    pass

    #else:
    #    print(e)

    def move(coords, move):
        return [ coords[0] + move[0], coords[1] + move[1] ]

    # Compute moves
    woman_newcoords = move(woman_coords, woman_move)
    man_newcoords = move(man_coords, man_move)
    snake_newcoords = move(snake_coords, snake_move)

    # But bound to window
    def bound(newcoords, coords, move):
        if newcoords[0] < 0 or newcoords[0] >= width or newcoords[1] < 0 or newcoords[1] >= height:
            # out of bounds
            newcoords[0] = coords[0]
            newcoords[1] = coords[1]
            move[0] = 0
            move[1] = 0

    bound(woman_newcoords, woman_coords, woman_move)
    bound(man_newcoords, man_coords, man_move)
    bound(snake_newcoords, snake_coords, snake_move)

    def collide(newcoords, coords, move):
        if map[newcoords[1]][newcoords[0]] == 'X':
            # Stone
            newcoords[0] = coords[0]
            newcoords[1] = coords[1]
            move[0] = 0
            move[1] = 0

    # Prevent collisions with stones
    collide(woman_newcoords, woman_coords, woman_move)
    collide(man_newcoords, man_coords, man_move)

    # Prevent collisions between players
    if woman_newcoords == man_newcoords:
        woman_newcoords = woman_coords
        woman_move = [ 0, 0 ]
        man_newcoords = man_coords
        man_move = [ 0, 0 ]

    # Make everybody move when everybody chose her/his direction
    if woman_move != [ 0, 0 ] and man_move != [ 0, 0 ] and snake_move != [ 0, 0 ]:
        woman_coords = woman_newcoords
        man_coords = man_newcoords
        snake_coords = snake_newcoords
        woman_move = [ 0, 0 ]
        man_move = [ 0, 0 ]
        snake_move = [ 0, 0 ]

    #logging.debug("woman at %u,%u to %u,%u" % (woman_coords[0], woman_coords[1], woman_newcoords[0], woman_newcoords[1]))
    #logging.debug("man at %u,%u to %u,%u" % (man_coords[0], man_coords[1], man_newcoords[0], man_newcoords[1]))
    #logging.debug("snake at %u,%u to %u,%u" % (snake_coords[0], snake_coords[1], snake_newcoords[0], snake_newcoords[1]))

    # Display everything
    screen.fill(grass)

    def blit(item, coords):
        screen.blit(item, (unit * coords[0], unit * coords[1]))

    # Display stones
    for y in range(len(map)):
        for x in range(len(map[y])):
            if map[y][x] == 'X':
                blit(stone, (x, y))

    # Display moving items
    blit(apple, apple_coords)

    blit(woman_ghost, woman_newcoords)
    blit(woman, woman_coords)
    blit(man_ghost, man_newcoords)
    blit(man, man_coords)

    blit(snake_ghost, snake_newcoords)
    blit(snake, snake_coords)

    # Show new state
    pygame.display.flip()

    if woman_coords == apple_coords:
        print("woman won!\n")
        sys.exit()
    elif man_coords == apple_coords:
        print("man won!\n")
        sys.exit()

    if woman_coords == snake_coords:
        print("woman lost!\n")
        sys.exit()
    elif man_coords == snake_coords:
        print("man lost!\n")
        sys.exit()
